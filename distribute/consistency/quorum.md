## Quorum

要解决数据一致性问题，就是数据的处理方式采用Read Only Write All原则，即在分布式环境中，所有节点更新完毕后，读操作才能进行，保证数据的强一致性。这种虽然保证了数据的在某一刻的强一致性，但是极其影响系统的性能。在一个读操作非常频繁的分布式环境中，写操作的耗时，直接阻塞了读的操作。导致读和写的负载不均衡。 

基于 Quorum机制的 NRW算法就是在读和写的负载上达到一定平衡的同时，保证数据的强一致性。机制的主要思想来源于鸽巢原理。即当数据备份存在N份时，k份数据已经更新，那么只要获取N−K+1个数据副本，至少有一个数据是更新了的。获取其中版本最高的那份数据，即最新的。这样，我们就不必等待所有数据副本全部更新后才去读取数据。把写操作的部分工作转移到了读操作中，使得读写能够在一定程度上达到负载均衡。

运用 Quorum 机制来解决读写模型中读写的负载均衡。其实，关键的是更新多少个数据副本后，使得读取时总能读到有效数据？回想我们的的红苹果，假设总共有 N 个数据副本，其中 k 个已经更新，N-k 个未更新的，那么我们任意读取 N-k+1 个数据的时候就必定至少有 1 个是属于更新了的 k 个里面的，也就是 Quorum 的交集，我们只需比较 读取的 N-k+1 中版本最高的那个数据返回给用户就可以得到最新更新的数据了。

那么对于写模型呢？我也只需要完成 k 个副本的更新后，就可以告诉用户操作完成而不需要 Write All 了，当然告诉完用户完成操作后，系统内部还是会慢慢的把剩余的副本更新，这对于用户是透明的。可以看到，我们把 Write 身上的部分负载转移到了 Read 上，Read 读取多个副本，使得 Write 不会过于劳累，不好的是弱化了分布式系统中的数据一致性。至于转移多少负载比较合适，这个需要根据分布式系统的具体需求中对数据一致性的要求。

### NRW算法

假设需要备份N个数据副本，读操作用R，写操作用W，操作副本用V表示。根据鸽巢原理，要保证操作能获得最新数据。则有以下制约条件。 
1. Vr+Vw>N即读操作副本量+写操作副本量必须大于数据副本量。这就即保证必定有一个副本是操作之后的值，同时保证了数据副本要么处于W写操作中，要么处于R读操作中。这里的读写状态是针对外部来讲的，分布式环境对外部来说，同一时刻只存在一种操作（容斥定理），相当于读写锁，但比加锁(一种悲观的策略)的方式更加高效。对于分布式环境内部，读和写操作只是部分节点的操作。同时限定了最小读副本数量和最小写副本数量。该策略中，只需要保证R+W>N，就可以保证强一致性。 如果R+W≤N，这时读取和写入操作是不重叠的，系统只能保证最终一致性，而副本达到一致的时间则依赖于系统异步更新的实现方式，不一致性的时间段也就等于从更新开始到所有的节点都异步完成更新之间的时间。 
2. Vw>N/2 保证了数据的串行化修改。一份数据的冗余拷贝不可能同时被两个写请求修改。如Vw<N/2的时候，就可能存在一部分数据被一个写操作修改，另一部分数据被另一个写操作修改。 
     
如图所示,在分布式环境A、B、C、D、E中，根据规则一，那么读写副本量应该至少为6，而现在副本只有5份，则至少有一份C即在读的数据副本中，也在写的数据副本中，才能保证获取到当前时刻最新的数据。规则二，如果Vw<N/2,就像如图所示的A、B写操作和E、D写操作一样，那么这时候整个分布式环境中就存在三种数据，造成数据的不一致性。 



### Vector Clock


https://www.zhihu.com/question/36757267


https://www.cnblogs.com/think90/p/8046925.html
